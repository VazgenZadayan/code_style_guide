export const JAVASCRIPT_RULES = [
{
  title: "ТОЧКА С ЗАПЯТОЙ",
  description: `В JavaScript допустимо не ставить в конце строк точку с запятой. Но такое написание считается “плохим тоном”.
В соответствии с данным стандартом все строки должны заканчиваться точками с запятой:
Есть языки, в которых точка с запятой необязательна и редко используется. Однако в JavaScript бывают случаи,
когда перенос строки не интерпретируется, как точка с запятой, что может привести к ошибкам.`,
  badExample: `
  const count = 10
  const obj = { a: 5, b: 10 }
  const func = function() {
    // code here
  }`,
  goodExample: `
  const count = 10;
  const obj = { a: 5, b: 10 };
  const func = function() {
  // code here
  };`,
},
{
  title: "ТАБУЛЯЦИЯ",
  description: `Отступы слева должны соответствовать уровню вложенности кода и должны быть единообразны во всём коде.
Рекомендуемый одинарный отступ - одна табуляция. Пробелы для отступов слева использовать не рекомендуется.`,
  badExample: `
  for(let i = 0; i < 10; i++) {
  if(a === b) {doThisAction(a);}
  }
  `,
  goodExample: `
  for(let i = 0; i < 10; i++) {
    if(a === b) {
      doThisAction(a);
    }
  }
  `,
},
{
  title: "ПРОБЕЛЫ В МАССИВАХ И ОБЪЕКТАХ",
  description: `В массивах первое и последнее значения не отделяется пробелом, после каждой запятой необходимо ставить пробел.`,
  badExample: `
  const array = [ 1, 2, 3, 4 ];
  const array = [1,2,3,4];
  const obj = {a:5, b:6};
  const obj = { a:5, b:6 };
  `,
  goodExample: `
  const array = [1, 2, 3, 4];
  const obj = {a: 5, b: 6};
  `,
},
{
  title: "ИМЕНОВАНИЕ ПЕРЕМЕННЫХ",
  description: `Все переменные должны быть названы в верблюжьем регистре (camelCase). Исключения составляют константы которые
должны именоваться прописными буквами в змеином регистре (UPPER_SNAKE_CASE)`,
  badExample: `
  let my_variable = 5;
  let MYVARIABLE = 5;
  let myvariable = 5;
  `,
  goodExample: `
  let myVariable = 5;
  let MY_VARIABLE = 5;
  `,
},
{
  title: "ИМЕНОВАНИЕ ФУНКЦИЙ",
  description: `Названия функций должны содержать глагол и четко отвечать на вопрос: “Что делает эта функция?”
Функции-конструкторы необходимо именовать с заглавной буквы.`,
  badExample: `
// Неправильно
  function myFunc() {};
  function randomNumber() {};
  `,
  goodExample: `
  function getRandomNumber() {};
  function validateForm() {};
  function setNewColor() {};
  `,
},
{
  title: "УСЛОВНЫЕ ОПЕРАТОРЫ(Switch)",
  description: `В случае, когда наше условие состоит из 3 или более обстоятельств рекомендуется использовать конструкцию Switch
При использовании ее запрещено использовать case без break или return.`,
  badExample: `
  if (a === b) {
    doSmth()
  } else if (a === c) {
    doSmth()
  } else if (a === d) {
    doSmth()
  }
  `,
  goodExample: `
  switch (a) {
    case b:
      doSmth()
      break;
    case c:
      doSmth()
      break;
    case d:
      doSmth()
      break;
    default:
      doSmth()
      break;
  }
  `,
},
{
  title: "УСЛОВНЫЕ ОПЕРАТОРЫ(If else)",
  description: `В большинстве JavaScript проектов фигурные скобки пишутся в так называемом «египетском» стиле с открывающей скобкой на той же строке,
что и соответствующее ключевое слово – не на новой строке. Перед открывающей скобкой должен быть пробел, как здесь:`,
  badExample: `
  if (n < 0) {alert("N меньше нуля");}
  if (n < 0)
    alert("N меньше нуля");
  if (n < 0) alert("N меньше нуля");
  `,
  goodExample: `
  if (n < 0) {
    alert("N меньше нуля");
  }
  if (
    id === 123 &&
    moonPhase === 'Waning Gibbous' &&
    zodiacSign === 'Libra'
  ) {
    letTheSorceryBegin();
  }
  `,
},
{
  title: "ПРОЧЕЕ",
  description: `ОГРОМНЫЕ МЕТОДЫ
Слишком большие методы являются источником ошибок и сложны для понимания.
Есть правило: функция должна выполнять одну задачу и выполнять её хорошо.

БОЖЕСТВЕННЫЙ ОБЪЕКТ
Так называют огромный класс, который делает слишком много разных вещей.
Класс, как и функция, должен иметь одну цель существования. Поэтому божественный объект
должен быть разделён на несколько сущностей, каждая из которых имеет только одну задачу.

ДУБЛИРУЮЩИЙСЯ КОД
Идентичный код, который разбросан по всему приложению.
Он увеличивает сложность поддержки и тестирования системы.
Повторяющиеся куски кода являются признаком того, что вам пора задуматься о рефакторинге.

ИЗБЫТОК ПАРАМЕТРОВ
Длинный список параметров усложняет чтение, вызов и тестирование функций.
Уменьшение числа параметров позволит вам сократить время на изучение и тестирование кода.

НЕУМЕСТНАЯ СЛОЖНОСТЬ
Принудительное использование чрезмерно сложных шаблонов проектирования там,
где более простой архитектуры было бы достаточно.
Использование сложных паттернов без необходимости показывает не ваш скилл,
а неспособность увидеть картину целиком и избежать излишней сложности.
`,
}
]